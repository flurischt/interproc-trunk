(** Representing equation system *)

(* This file is part of the Interproc analyzer, released under GPL license.
   Please read the COPYING file packaged in the distribution.

   Copyright (C) Mathias Argoud, Gaël Lalire, Bertrand Jeannet 2007.
*)

open Format;;

(*  ********************************************************************* *)
(** {2 Instanciated modules} *)
(*  ********************************************************************* *)

(** {3 Sets of control points} *)

let compare_point (a:Spl_syn.point) (b:Spl_syn.point) =
  a.Spl_syn.char - b.Spl_syn.char

let equal_point (a:Spl_syn.point) (b:Spl_syn.point) =
   (a.Spl_syn.char == b.Spl_syn.char)
 
module SetteP = Sette.Make(struct
  type t=Spl_syn.point
  let compare = compare_point
end)
module HashheP = Hashhe.Make(struct
  type t=Spl_syn.point
  let equal = equal_point
  let hash x = x.Spl_syn.char
end)

(** {3 Graphs representing equation systems} *)

(** Parameter module for hypergraph (will describe equation system) *)
module T = struct
  type vertex=Spl_syn.point
  type hedge=int
  let vertex_dummy = { Spl_syn.line=(-1); Spl_syn.col=(-1); Spl_syn.char=(-1) }
  let hedge_dummy = (-1)
  module SetV=SetteP
    (** Set module for vertices *)
  module SetH=SetteI
    (** Set module for hyperedges *)
  module HashV=HashheP
    (** Hash module for vertices *)
  module HashH=HashheI
    (** Hash module for hyperedges *)
end

(** Hypergraphs describing equation system) *)
module Graph = SHGraph.Make(T) 


(*  ********************************************************************* *)
(** {2 Preprocessed information} *)
(*  ********************************************************************* *)

(** Useful information associated to a procedure *)
type procinfo = {
  pname : string;        (** Procedure name *)
  pstart: Spl_syn.point; (** Procedure start point *)
  pexit: Spl_syn.point;  (** Procedure exit point *)
  pinput: Apron.Var.t array;  (** Array of input variables *)
  poutput: Apron.Var.t array; (** Array of output variables *)
  plocal: Apron.Var.t array;  (** Array of other variables *)
  penv: Apron.Environment.t;  (** Environment of the procedure *)
  poutput_tmp: Apron.Var.t array; (** Array of renamed output variables *)
}

(** Useful information for the program *)
type info = {
  procinfo : (string, procinfo) Hashhe.t;
    (** Hashtable [procedure name -> procinfo].
        Main procedure has empty name *)
  callret : (Spl_syn.point,Spl_syn.point) DHashhe.t;
    (** Two-way association call points/return points generated by procedure
      calls. *)
  pointenv : (Spl_syn.point,Apron.Environment.t) Hashhe.t;
    (** Hashtable [point -> environment of the enclosing procedure]. *)
  mutable counter : int;
    (** Last free hyperedge identifier (used by [add_equation]). *)
}

(*  ********************************************************************* *)
(** {2 Equation system} *)
(*  ********************************************************************* *)

(** A variable in an equation = a control point *)
type var = Spl_syn.point

(** Information associated to hyperedges/functions used in equations *)
type transfer =
  | Lassign of Apron.Var.t * Apron.Linexpr1.t
      (** Assignement by a linear expression *)
  | Tassign of Apron.Var.t * Apron.Texpr1.t
      (** Assignement by a tree expression *)
  | Condition of Apron.Tcons1.t Boolexpr.t
      (** Filtering of a predicate by a Boolean expression *)
  | Call of procinfo * procinfo * (Apron.Var.t array) * (Apron.Var.t array)
      (** Procedure call, of the form
	[Call(callerinfo,calleeinfo,actual input parameters,actual output parameters)] *)
  | Return of procinfo * procinfo * (Apron.Var.t array) * (Apron.Var.t array)
      (** Procedure return, of the form
	[Call(callerinfo,calleeinfo,actual input parameters,actual output parameters)] *)

(** Equation system, represented by a graph, where vertex identifiers are
control point, and hyperedge identifiers are integers, with which are
associated objects of type [transfer]. Global information associated with the
graph is of type [info]. *)
type graph = (unit,transfer,info) Graph.t

(*  ********************************************************************* *)
(** {2 Functions} *)
(*  ********************************************************************* *)

(** Adding an equation *)
let add_equation (graph:graph) (torg:var array) (transfer:transfer) (dest:var)
  : 
  unit

  =
  Array.iter
    (begin fun var ->
      if not (Graph.is_vertex graph var) then Graph.add_vertex graph var ()
    end)
    torg
  ;
  if not (Graph.is_vertex graph dest) then Graph.add_vertex graph dest ();
  if transfer<>(Condition(Boolexpr.CST(false))) then begin
    let info = Graph.info graph in
    Graph.add_hedge graph info.counter transfer ~pred:torg ~succ:[|dest|];
    info.counter <- info.counter + 1;
  end;
  ()

(*  ===================================================================== *)
(** {3 Printing functions} *)
(*  ===================================================================== *)

let print_tvar fmt (tvar:Apron.Var.t array) =
  PSpl_syn.print_list
    ~first:"[|@[<hov>" ~sep:";@ " ~last:"@]|]"
    Apron.Var.print
    fmt (Array.to_list tvar)

let print_procinfo fmt procinfo =
  fprintf fmt "{ @[<v>pstart = %a;@ pexit = %a;@ pinput = %a;@ poutput = %a;@ plocal = %a;@ penv = %a;@ poutput_tmp = %a;@] }"
    PSpl_syn.print_point procinfo.pstart
    PSpl_syn.print_point procinfo.pexit
    print_tvar procinfo.pinput
    print_tvar procinfo.poutput
    print_tvar procinfo.plocal
    (fun fmt e -> Apron.Environment.print fmt e) procinfo.penv
    print_tvar procinfo.poutput_tmp

let print_info fmt info =
  fprintf fmt "{ @[<v>procinfo = %a;@ callret = %a;@ pointenv = %a;@ counter = %i;@] }"
    (Hashhe.print pp_print_string print_procinfo) info.procinfo
    (DHashhe.print PSpl_syn.print_point PSpl_syn.print_point) info.callret
    (Hashhe.print PSpl_syn.print_point Apron.Environment.print) info.pointenv
    info.counter

let print_transfer fmt transfer = match transfer with
  | Lassign _ -> failwith ""
  | Tassign(v,e) -> 
      fprintf fmt "%a = %a"
      Apron.Var.print v
      Apron.Texpr1.print e
  | Condition(bexpr) ->
      fprintf fmt "IF %a"
      (Boolexpr.print Apron.Tcons1.print) bexpr
  | Call(callerinfo,calleeinfo,pin,pout) ->
      fprintf fmt "CALL %a = %s(%a)"
      print_tvar pout
      calleeinfo.pname
      print_tvar pin  
  | Return(callerinfo,calleeinfo,pin,pout) ->
      fprintf fmt "RETURN %a = %s(%a)"
      print_tvar pout
      calleeinfo.pname
      print_tvar pin
